{"meta":{"title":"klevan blogs","subtitle":null,"description":null,"author":"klevan","url":"http://yoursite.com"},"pages":[{"title":"About Me","date":"2017-10-30T09:40:04.000Z","updated":"2017-10-30T09:40:04.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-10-25T04:56:11.000Z","updated":"2017-10-25T04:56:11.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-10-25T04:56:11.000Z","updated":"2017-10-25T04:56:11.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java类文件结构解析（二）","slug":"javabytecode2","date":"2017-10-31T09:01:51.000Z","updated":"2017-10-31T17:51:16.000Z","comments":true,"path":"javabytecode2/","link":"","permalink":"http://yoursite.com/javabytecode2/","excerpt":"","text":"承接上文 Java类文件结构解析（一），这里对照着字节码继续看一下字节码文件的具体结构。从第一个16进制符往下看： cafebabe 0000 0034 ，十进制大小为52 。表示魔数，指的是该class文件可以被java加载的版本号。 0017 :表示这个类的常量池大小为23，那么常量池大小为22，之所以少一位，是因为0空出来特殊场景下表示不引用任何一个常量池项目。常量池中主要存放两类常量：字面量跟符号引用。常量池中的每一项常量都是一个表。目前共有14种不同类型的表结构。且这14种表结构的首位都是一个u1类型的标志位，代表当前这个常量属于哪种常量类型。这14种常量的意思列表如下: 类型 标志 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整形字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度浮点型字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型字面量 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MothodType_info 16 标志方法类型 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 对照这个表，我们继续往下看常量池中的第一项常量是0a，表示十进制值10，查上表，是CONSTANT_Methodref_info,表示类中方法的符号索引。在下表中进一步查询该常量项的结构: 在上表中查看结构是CONSTANT_Methodref_info的结构可知，表中的第一项是u1类型的标志位tag，用于区分常量类型，第二项是u2类型的索引index,第三项同样是是u2类型的index，分表表示： - 0006: 6,指向CONSTANT_Class_info,即常量池的第六个常量。 - 0011: 17，常量池的第17个常量。 在Java类文件结构解析（一）文章中，我们通过javap命令拿到了详细的常量池信息，对比之下，可以知道6指向的是常量#22，也就是java/lang/Object，同理17指向的是”“:()V。同样的寻找方式，我们把下面的所有十六进制对应的常量池信息都列出来： 二:08:8,查表，字符串类型的字面量，CONSTANT_String_info 0012 ：18，指向字符串字面量的引用 三：09 ：9 ，是字段的符号引用，CONSTANT_Fieldref_info 0005 0013 四：08 0014 五：07，CONSTANT_Class_info 0015 六：07 0016 七：01 ：CONSTANT_Utf8_info 0004 ：长度是4的字符串,查ASCII码表，分别为字符串： 74 : t 65 : e 73 : s 74 : t 八：01 ：CONSTANT_Utf8_info 0012 ：长度为18字节的字符串 4c6a6176612f6c616e672f537472696e673b ：Ljava/lang/String; 九：01 0006 ：长度为6字节的字符串 3c696e69743e ： 十：01 0003：长度为3字节的字符串 282956： ()V 十一：01 0004 ：长度为4字节的字符串 436f6465 ：Code 十二：01 000f：长度为15字节的字符串 4c696e654e756d6265725461626c65：LineNumberTable 十三：01 0007 67657454657374 十四：01 0014 ：20 28294c6a6176612f6c616e672f537472696e673b ：()Ljava/lang/String; 十五：01 000a 536f7572636546696c65 十六：01 0011 ：17 4a617661436f6465546573742e6a617661 十七：0c ：12 ，CONSTANT_Class_info，字段或者方法的部分符号引用 0009：指向字段或者方法名称常量项的引用，指向第九个常量，也就是 000a：指向字段或者方法描述符常量项的引用，即()V 十八：01 000e：14 6a61766120636f64652074657374 ：java code test 十九：0c ：12，，CONSTANT_Class_info，字段或者方法的部分符号引用 0007：7，指向第七个常量：test 0008：8，指向第八个常量 二十：01： 0005：5个常量 6365736869 二十一：01 000c：12， 4a617661436f646554657374 二十二：01 0010 ：16个 6a6176612f6c616e672f4f626a656374—–以上常量池信息结束—– 紧跟着常量池结尾后的的两个字节： 0021 ：代表访问标志（access_flags）,用于识别类或者接口层次的访问信息； 0005 ：类索引，指向常量池变量5：JavaCodeTest 0006：父类索引，指向常量池变量：java/lang/Object， 0000：接口索引为0，所以没有实现接口 下面字段表信息开始：用于描述接口或类中申明的变量。 0001:容量计数器，fields_count=1，表示只有一个字段表数据； 0002：字段表的access_flags,表示字段是private； 0007:name_index,7,指向常量池的第七项常量：test； 0008：描述字段，descriptor_index:8,指向常量池的第八项常量：Ljava/lang/String;最终得出字符串：private String test; 0000:attributes_count=0,表示没有额外描述的信息；———字段信息结束——– 下面方法表集合开始。 0002：容量计数器：表示类有两个方法 0001：access_flags=1,ACC_PUBLIC,表示public方法 0009： 指向常量池，方法名： 000a:方法描述符索引：10，()V，表示特殊类型void， 0001：attributes_count,属性计数器1，表示方法含有一项属性；下面属性表集合开始。 000b：attribute_name_index,属性的名称索引，11：Code，表示此属性是方法的字节码描述； 00000027：attribute_length，39 0002:max_stack,操作数栈的最大深度为2， 0001：max_locals，局部变量表所需的存储空间为1； 0000000b：code_length:字节码指令长度：11 2a:对应指令：aload_0，意思是把第一个引用类型本地变量推送到栈顶，也就是把String test 推送到栈顶； b7：对应指令：invokespecial,调用本对象的实例构造器方法、private方法、父类方法，后面跟一个u2类型的参数 0001：参数：表示调用的是哪一个方法，这里指：java/lang/Object.”“:()V 2a ：aload_0 12 ：ldc:把int/float/String类型常量值从常量池中推送到栈顶,后面跟一个参数表示推送的常量值在常量池中的位置 02 ：ldc的参数，指向常量池中的第二个位置； b5 ：putfiled:为指定类的实例域赋值， 0003 ：参数，把ldc推送的常量赋值给putfiled指向的3的变量； b1 ：return:从当前方法返回void； 之后紧跟着的是属性计数器~~待补充","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"}]},{"title":"Java类文件结构解析（一）","slug":"javabytecode","date":"2017-10-25T09:01:51.000Z","updated":"2017-10-31T17:31:13.000Z","comments":true,"path":"javabytecode/","link":"","permalink":"http://yoursite.com/javabytecode/","excerpt":"作为一个Java开发，每天编写的Java代码都是成百上千行，略去枯燥的业务代码不提，追寻代码从编译成class文件开始，虚拟机如何加载、解析这些代码的过程，一定要比单纯写业务代码有意思的多。 一、class文件的结构我们日常开发的过程大致是这样的，我要提供个某某功能的服务，所以，我们开始巴拉巴拉、、 123public class AaBaServiceImpl implements AaBaService &#123; //巴拉巴拉一堆代码：服务依赖、变量定义、方法定义、常量、日志 等等等&#125;","text":"作为一个Java开发，每天编写的Java代码都是成百上千行，略去枯燥的业务代码不提，追寻代码从编译成class文件开始，虚拟机如何加载、解析这些代码的过程，一定要比单纯写业务代码有意思的多。 一、class文件的结构我们日常开发的过程大致是这样的，我要提供个某某功能的服务，所以，我们开始巴拉巴拉、、 123public class AaBaServiceImpl implements AaBaService &#123; //巴拉巴拉一堆代码：服务依赖、变量定义、方法定义、常量、日志 等等等&#125; 是不是机械的很，熟练的不行啊，快飞起来了。瞬间觉得自己狂拽掉咋天。BUT FUCK为啥我非要写成这样？我可是程序员啊 ，创造力无限的说，咋就不能一朝顿悟，一掌辟出个黯然销魂掌？答曰：那必须不能啊，因为神雕侠侣特么它不是你写的啊。类比可知：Java特么也不是你发明的，人家的规范早就定义好了，在这个基础规范里面，文件结构那只能这么搞，为了一个崇高的“梦想”：师夷长技以制夷。万一哪天牛逼了，一不小心独创了个语言呢？人家杨过那也是厚积薄发，内力深厚，阅经沧桑，不然还销魂啥啊，没等销魂，就被蛤蟆功撑死了。所以，先积一下。来看看这个虚拟机规范 ，章节翻到第四节：Chapter 4. The class File Format，类文件格式： 123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; 这里u4、u2表示的4个字节，2个字节的意思。但是这么看起来还是很抽象，不明觉厉。那先画个图给他串一下，顺便，把这几个英文的意思也标记一下： 对照着图，分别简单聊一下这些class文件的结构内容： magic：魔数。值是十六进制：CAFEBABE。作用是标记文件的身份，也就是标记该文件是否可以被虚拟机接受。 minor_version: 次版本号。 major_version：主版本号。 这两哥们决定了类文件版本格式。简单的说，就是决定类文件可以被哪个版本的虚拟机执行。假设minor_version的值是M，major_version的值是m，那么这个类的版本号就是M.m。 constant_pool_count：常量池统计数。表示常量池的大小。 constant_pool：常量池。大小是constant_pool_count-1。常量池的主要内容是字面量和符号引用。 access_flags：访问标志。表示类或者接口的访问信息。比如是Class还是Interface，定义域是不是public，Class是不是抽象的等。 this_class: 类索引。标记这个类的全量名，指向常量值的字面量。 super_class: 父类索引。标记类父类的全量名。 interfaces_count：接口计数器。表示接口的数量。 interfaces：具体的接口信息。 fields_count：字段信息计数器，用来描述接口或者类中的声明的变量。 fields: 字段的具体信息。 methods_count：方法表计数器。 methods：方法表具体信息。 attributes_count：属性表计数器。 attributes：属性表具体信息。 二、具体代码实例的对比拿到类文件的结构以后，我们写一个简单的java代码做个对比，源文件代码如下：12345678public class JavaCodeTest &#123; private String test = \"java code test\"; public String getTest()&#123; return \"ceshi\"; &#125;&#125; 有了源文件以后，需要把源文件编译成Java字节码，以供我们学习比对，首先执行javac JavaCodeTest.java，编译成class文件，之后需要查看编译后的class文件以及其二进制的内容，这里简单介绍一下具体方法： 1.命令行方式查看class文件的内容：1javap -verbose JavaCodeTest 执行后的结果会带常量池的具体信息，如果不想查看常量池，执行javap -c filenName即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Compiled from \"JavaCodeTest.java\"public class JavaCodeTest minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#17 // java/lang/Object.\"&lt;init&gt;\":()V #2 = String #18 // java code test #3 = Fieldref #5.#19 // JavaCodeTest.test:Ljava/lang/String; #4 = String #20 // ceshi #5 = Class #21 // JavaCodeTest #6 = Class #22 // java/lang/Object #7 = Utf8 test #8 = Utf8 Ljava/lang/String; #9 = Utf8 &lt;init&gt; #10 = Utf8 ()V #11 = Utf8 Code #12 = Utf8 LineNumberTable #13 = Utf8 getTest #14 = Utf8 ()Ljava/lang/String; #15 = Utf8 SourceFile #16 = Utf8 JavaCodeTest.java #17 = NameAndType #9:#10 // \"&lt;init&gt;\":()V #18 = Utf8 java code test #19 = NameAndType #7:#8 // test:Ljava/lang/String; #20 = Utf8 ceshi #21 = Utf8 JavaCodeTest #22 = Utf8 java/lang/Object&#123; public JavaCodeTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: aload_0 5: ldc #2 // String java code test 7: putfield #3 // Field test:Ljava/lang/String; 10: return LineNumberTable: line 4: 0 line 5: 4 public java.lang.String getTest(); descriptor: ()Ljava/lang/String; flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: ldc #4 // String ceshi 2: areturn LineNumberTable: line 8: 0&#125;SourceFile: \"JavaCodeTest.java\" 2.命令行查看十六进制的class文件内容1231）首先以二进制方式编辑这个文件：vi -b datafile2）使用xxd转换为16进制：:%!xxd3）转换16进制回来vi：:%!xxd -r 执行完命令1跟2后，命令行显示内容如下： 1234567891011121314151617181920212200000000: cafe babe 0000 0034 0017 0a00 0600 1108 .......4........00000010: 0012 0900 0500 1308 0014 0700 1507 0016 ................00000020: 0100 0474 6573 7401 0012 4c6a 6176 612f ...test...Ljava/00000030: 6c61 6e67 2f53 7472 696e 673b 0100 063c lang/String;...&lt;00000040: 696e 6974 3e01 0003 2829 5601 0004 436f init&gt;...()V...Co00000050: 6465 0100 0f4c 696e 654e 756d 6265 7254 de...LineNumberT00000060: 6162 6c65 0100 0767 6574 5465 7374 0100 able...getTest..00000070: 1428 294c 6a61 7661 2f6c 616e 672f 5374 .()Ljava/lang/St00000080: 7269 6e67 3b01 000a 536f 7572 6365 4669 ring;...SourceFi00000090: 6c65 0100 114a 6176 6143 6f64 6554 6573 le...JavaCodeTes000000a0: 742e 6a61 7661 0c00 0900 0a01 000e 6a61 t.java........ja000000b0: 7661 2063 6f64 6520 7465 7374 0c00 0700 va code test....000000c0: 0801 0005 6365 7368 6901 000c 4a61 7661 ....ceshi...Java000000d0: 436f 6465 5465 7374 0100 106a 6176 612f CodeTest...java/000000e0: 6c61 6e67 2f4f 626a 6563 7400 2100 0500 lang/Object.!...000000f0: 0600 0000 0100 0200 0700 0800 0000 0200 ................00000100: 0100 0900 0a00 0100 0b00 0000 2700 0200 ............'...00000110: 0100 0000 0b2a b700 012a 1202 b500 03b1 .....*...*......00000120: 0000 0001 000c 0000 000a 0002 0000 0004 ................00000130: 0004 0005 0001 000d 000e 0001 000b 0000 ................00000140: 001b 0001 0001 0000 0003 1204 b000 0000 ................00000150: 0100 0c00 0000 0600 0100 0000 0800 0100 ................ 这个内容看起来不纯粹，进一步把class文件用sublime编辑工具打开，打开后的效果如下： 1234567891011121314151617181920212223cafe babe 0000 0034 0017 0a00 0600 11080012 0900 0500 1308 0014 0700 1507 00160100 0474 6573 7401 0012 4c6a 6176 612f6c61 6e67 2f53 7472 696e 673b 0100 063c696e 6974 3e01 0003 2829 5601 0004 436f6465 0100 0f4c 696e 654e 756d 6265 72546162 6c65 0100 0767 6574 5465 7374 01001428 294c 6a61 7661 2f6c 616e 672f 53747269 6e67 3b01 000a 536f 7572 6365 46696c65 0100 114a 6176 6143 6f64 6554 6573742e 6a61 7661 0c00 0900 0a01 000e 6a617661 2063 6f64 6520 7465 7374 0c00 07000801 0005 6365 7368 6901 000c 4a61 7661436f 6465 5465 7374 0100 106a 6176 612f6c61 6e67 2f4f 626a 6563 7400 2100 05000600 0000 0100 0200 0700 0800 0000 02000100 0900 0a00 0100 0b00 0000 2700 02000100 0000 0b2a b700 012a 1202 b500 03b10000 0001 000c 0000 000a 0002 0000 00040004 0005 0001 000d 000e 0001 000b 0000001b 0001 0001 0000 0003 1204 b000 00000100 0c00 0000 0600 0100 0000 0800 01000f00 0000 0200 10 这样看起来清爽多了，没有无关的东西了，只剩下纯粹的16进制码了。 这里多说一句，Java中byte用二进制表示要占用8位，而16进制的每个字符需要用4位二进制位来表示，所以我们就可以把每个byte转换成两个相应的16进制字符，即把byte的高4位和低4位分别转换成相应的16进制字符，并组合起来得到byte转换到16进制字符串的结果。即byte用十六进制表示只占2位。同理，相反的转换也是将两个16进制字符转换成一个byte，原理同上。 接下来会讲一下对照着这些十六进制码如何查看class字节码的具体内容~~~","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"}]}]}